Metadata-Version: 2.4
Name: log-pdm-lib
Version: 1.0
Summary: Модель для предиктивной диагностики компьютерных систем по их логам
Author-email: Vladislav Kiryachek <w.a.kiryachok@mail.ru>
Requires-Python: >=3.11
Description-Content-Type: text/markdown
Requires-Dist: matplotlib==3.10.3
Requires-Dist: numpy==1.26.4
Requires-Dist: pandas==2.3.0
Requires-Dist: scikit-learn==1.7.0
Requires-Dist: gensim==4.3.3
Requires-Dist: plotly==6.2.0
Requires-Dist: torch==2.7.1

# Инструкция по установке и использованию библиотеки

## Требования

Python 3.11+, Windows 10+, видеокарта NVIDIA с CUDA (желательно)

## Локальная установка
   1. Установите python 3.11+
   2. Создайте виртуальное окружение
      `python -m venv .venv`
   3. Активируйте виртуальное окружение
      `.venv\Scripts\activate`
   4. Клонируйте репозиторий
      `git clone git@gitlab.dev002.local:tribes/dga-tribe/datascience-team/predictive-diagnostic-system/pd-autoencoders-lib.git`
   5. `cd .\pd-autoencoders-lib\`
   6. `python -m pip install pip --upgrade`
   7. Установите requirements
      `pip install -r requirements.txt`
   8. Установите репозиторий в виде библиотеки
      `py -m pip install --upgrade build`
      `py -m build`
      `pip install ./dist/pd_autoencoders_lib-1.0.tar.gz`
   9. Проверьте что тесты отрабатывают корректно
      `pytest tests`

## Демо
   1. В папке demo найдите файл `config.json`. В нем укажите путь до папок с тренировочными (`"train_path"`) и тестовыми (`"test_path"`) данными, а также уставками `"tags_info_path"`.Опционально можно поменять папку с результатами (`"output_path"`, по умолчанию, результаты будут сохраняться в папку `./demo/output`). В поле `"tag"` можно указать тег, для которогобуду сохранены графики модельных данных (*estimated*) и невязки (*residuals*), если в поле стоит `null` - графики будут сохранены для случайного тега.
   2. В файле `model_parameters.json` можно указывать параметры модели
   3. В файле `fit_parameters.json` можно указывать параметры обучения, а также устройство, на котором будет проходить расчет (видеокарта - `"cuda"`, либо процессор - `"cpu"`)
   4. В файле `predict_parameters.json` можно указывать параметры инференса, а также веса тегов для ИТС `"weights_tags"` в виде списка
   5. Описание результатов (по умолчанию, в папке `./demo/output`):
      * `blue_green_line.html` - файл с синей (наблюдаемые данные) и зеленой (модельные данные) линией для заданного тега
      * `residuals.html` - файл с остатками (невязкой) для заданного тега
      * `health_index.html` - индекс технического состояния (ИТС)
      * `estimated.xlsx` - таблица с оцененными (модельными) данными тегов
      * `residuals.xlsx` - таблица с остатками (невязкой) по тегам
   6. Запуск демо
      `cd .\demo\`
      `python ae_demo.py config.json`
   
## Описание библиотеки autoencoder_models
   1. Файл `ae_model.py` содержит класс `AEModel`, реализующий Автоэнкодеры различных типов для решения задач Предиктивной диагностики. Всего поддерживается пять архитектур Автоэнкодеров (параметр `architecture` в `AEModel`):
      * линейный (`"linear"`)
      * рекуррентный (`"rnn"`)
      * линейный со свертками (`"conv+linear"`)
      * рекуррентный со свертками (`"conv+rnn"`)
      * рекуррентный со свертками и линейными слоями (`"conv+rnn+linear"`)
   Свойства конкретной архитектуры Автоэнкодера указываются в параметре `nn_properties` в виде словаря `dict`. Примеры `nn_properties` можно посмотреть в докстринге класса `AEModel`.
   Также можно выбрать один из трех скейлеров (`scale_model_name`), включить ли дополнение последовательности до заданного размера окна (`padding`), размер батча (`batch_size`) и *seed* для воспроизводимости (`random_state`).
   2. Обучение модели производится с помощью вызова метода `fit` со следующими параметрами:
      * `train_data` - тренировочный датасет (обязательный параметр)
      * `valid_data` - валидационный датасет (опционально, по умолчанию `null`)
      * `learning_rate` - скорость обучения (опционально, по умолчанию `1e-3`)
      * `epochs` - количество эпох (опционально, по умолчанию `500`)
      * `warmup` - доля эпох для прогрева (опционально, по умолчанию `0.2`)
      * `loss_function` - функция потерь (опционально, по умолчанию `"huberloss"`)
      * `device` - устройство для вычислений (опционально, по умолчанию `"cuda"`)
      * `eps_early_stop` - порог для ранней остановки (опционально, по умолчанию `1e-5`)
      * `stopping_rounds` - количество эпох для проверки остановки (опционально, по умолчанию `10`)
      * `verbose` - флаг вывода информации (опционально, по умолчанию `false`)
   3. Инференс модели производится с помощью вызова метода `predict` со следующими параметрами:
      * `test_data` - тестовый датасет (обязательный параметр)
      * `weights_tags` - веса признаков (тегов) (опционально, по умолчанию `null`)
      * `return_health_index` - флаг возврата индекса технического состояния (опционально, по умолчанию `false`)
      * `device` - устройство для вычислений (опционально, по умолчанию `"cuda"`)
      * `verbose` - флаг вывода информации (опционально, по умолчанию `false`)
   4. Вычисление порогового значения для индекса технического состояния делается с помощью метода `calc_warn_ucl` с параметрами:
      * `valid_data` - датасет для расчета порога (обязательный параметр)
      * `weights_tags` - веса признаков (тегов) (опционально, по умолчанию `null`)
      * `health_index_quantile` - квантиль для расчета порога (опционально, по умолчанию `0.99`)
      * `device` - устройство для вычислений (опционально, по умолчанию `"cuda"`)
   5. Сериализация и десериализация модели происходит с помощью методов `save_model` и `load_model`. В итоге, `save_model` возвращает словарь `dict` с параметрами модели и веса Автоэнкодера в бинарном представлении и типом `str`, а `load_model` принимает их на вход и возвращает экземпляр класса.
   6. Конкретные архитектуры Автоэнкодеров находятся в следующих файлах:
      * `linear_ae.py` - линейный Автоэнкодер
      * `conv_ae.py` - сверточный Автоэнкодер
      * `rnn_ae.py` - рекуррентный Автоэнкодер
      * `conv_linear.py` - линейный со свертками Автоэнкодер
      * `conv_rnn.py` - рекуррентный со свертками Автоэнкодер
      * `conv_rnn_linear.py` - рекуррентный со свертками и линейными слоями Автоэнкодер
   7. Вспомогательные функции для `ae_model.py` лежат в файле `tool_ae.py`, а именно `get_scaler`, `get_loss_func`, `get_activation_func`, `get_normalization_func` и `get_rnn_type`.
   8. Коды ошибок и их описания лежат в `constants_ae.py`.
